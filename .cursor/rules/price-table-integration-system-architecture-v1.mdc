---
name: price-table-integration-system-architecture-v1
description: system-architecture
---

# Overview
# ARCH_A_단가표_통합관리_단일서버_최소워커_아키텍처_v1

> 대상: **단가표 통합 관리 시스템** (본사 단가 + 거래처 단가 업로드/비교)  
> 전제: **서버 1대**, 사용자 약 **50명 내외**, 동시접속/동시업로드 낮음, 운영 단순성 최우선  
> 목적: SSOT 무결성 + 업로드(특히 이미지→테이블) 안정 처리 + 비교/조회 UX 유지

---

## 1. 아키텍처 목표와 원칙

### 1.1 목표
- **SSOT 무결성**: 모든 가격/비교/업로드 결과는 SSOT 모델에 연결(중복/자동 생성 금지)
- **업로드 안정성**: 30초 이상 걸릴 수 있는 변환 작업은 UI/조회 기능에 영향을 최소화
- **운영 단순**: 서버 1대에서 Docker Compose로 운영 가능한 최소 구성
- **운영 신뢰**: 감사로그(변경 전/후), 적용(Apply) 충돌 방지, 실패/재시도 UX

### 1.2 핵심 원칙
- 시스템을 성격에 따라 **Core(빠른 조회/비교)** 와 **Ingestion(느린 변환/매칭)** 으로 분리한다.
- 업로드 처리(엑셀/이미지)는 **job_id 기반 비동기 처리**로 분리한다.
- 큐/브로커는 과하지 않게: **Redis 1개로 큐+캐시를 겸용**(RabbitMQ 등은 제외)
- “서버 1대” 환경에서 장애 포인트 최소화를 위해 **컴포넌트 수를 제한**한다.

---

## 2. 최종 권장 컴포넌트(서버 1대)

### 2.1 구성 요소
- **Web**: Next.js + TypeScript (Admin/Viewer UI)
- **API**: FastAPI (Core + Upload Orchestrator)
- **DB**: PostgreSQL (SSOT/가격/비교/권한/감사로그/job 상태)
- **Storage**: 서버 로컬 디스크(초기)  
  - *옵션*: S3 호환 스토리지로 교체 가능한 추상화(추후 확장)
- **Queue/Cache**: Redis 1개 (job queue + read cache)
- **Worker**: Python Worker 1개 (엑셀 파싱, 이미지→테이블, 매칭 후보 생성)

### 2.2 왜 이 구성이 최적인가(현재 조건 기준)
- 업로드는 길고 실패 가능성이 있으므로 **동기 요청-응답으로 묶지 않는다**
- 사용자/트래픽이 작으므로 “클라우드 네이티브 풀세팅” 대신 **단일 서버 최소 구성**이 운영 효율이 가장 높다
- Redis 1개로 큐/캐시를 해결해 **운영 복잡도를 크게 줄인다**

---

## 3. 시스템 경계(도메인 분리)

### 3.1 Core 영역 (빠른 조회/비교, 무결성 중심)
- SSOT 모델 관리(제조사/타입/시리즈/모델명/스토리지/모델코드/활성)
- 본사 단가(등급별 기본가) 관리
- 거래처 단가(SSOT 기준 매핑된 단가) 조회/비교
- 비교 리스트
  - 관리자 지정 비교 리스트(개수 가변)
  - 사용자 개인 리스트/즐겨찾기
- 권한(RBAC: Admin/Viewer)
- 감사로그(변경 전/후)
- 적용(Apply) 잠금 정책

### 3.2 Ingestion 영역 (느린 변환, 검수 중심)
- 업로드 원본 파일 저장
- 엑셀/이미지 파싱 결과(추출 테이블)
- SSOT 매칭 후보(신뢰도 포함)
- 검수 확정 결과(저장/적용 가능한 상태)

---

## 4. 업로드 처리 플로우(정답 흐름)

### 4.1 공통: job_id 비동기 처리
1) UI 업로드 요청 → API는 **즉시 job_id 반환**
2) Worker가 백그라운드에서 처리
3) UI는 `GET /jobs/{job_id}`로 **5초 폴링**(초기)하여 상태 확인
4) 완료 시 결과 화면(검수 화면)으로 이동

### 4.2 본사 엑셀 업로드(모델코드 1차 매칭)
- 흐름: **업로드 → 자동 매핑(모델코드) → 검수 → 확정 → 적용**
- 정책: **SSOT에 없는 모델은 자동 생성 금지**
  - 미매핑은 “제외/보류/SSOT 등록 후 재업로드”로 처리

### 4.3 거래처 이미지 업로드(핵심: 이미지→테이블→매칭→검수)
- 흐름: **이미지 업로드 → 테이블 변환 → SSOT 매칭 후보 생성 → 검수 → 저장**
- Worker 작업(예시 단계)
  - 이미지 전처리(기울기/리사이즈/샤프닝 등)
  - OCR/표 구조 추출
  - 정규화(모델명/용량/가격 컬럼 정리)
  - SSOT 후보 N개 + 신뢰도 산출
- 검수 결과 확정 시 “거래처 표기 ↔ SSOT 모델” 매핑이 누적되어 자동 매칭률이 상승

---

## 5. Job 모델(상태/진행률/실패처리)

### 5.1 상태(최소 표준)
- `queued` → `running` → `succeeded` | `failed`

### 5.2 진행률(초기 전략)
- 초기에는 단계 기반(예: 0/25/50/75/100)으로 충분  
- 단계: 업로드 확인 → 파싱/추출 → 매칭 후보 생성 → 결과 저장

### 5.3 실패 처리(운영 필수)
- 실패 사유를 사용자에게 제공(예: 이미지 품질/표 구조 불명확/컬럼 누락 등)
- 재시도 버튼 제공(새 job 생성)
- 결과가 부분적으로만 나왔을 때도 “검수 화면에서 복구 가능한 형태”를 우선

---

## 6. 운영 안정 장치(서버 1대에서 필수)

### 6.1 적용(Apply) 잠금(충돌 방지)
- 본사 단가표는 “현재 적용본”이 존재하므로 동시에 적용 시 덮어쓰기 충돌 가능
- 해결: 적용 시점에 **락을 걸어 한 번에 1명만 적용**

### 6.2 멱등성(중복 실행 방지)
- 같은 파일/같은 요청이 중복 실행되지 않도록
  - 업로드 파일 해시/업로드 ID로 중복 방지 권장

### 6.3 감사로그(변경 전/후)
- 누가/언제/무엇을/어떻게 + 변경 전/후 저장
- 대상: SSOT, 등급, 본사단가, 거래처단가, 업로드(검수/확정/적용), 사용자/권한

---

## 7. 배포 형태(단일 서버 운영)

### 7.1 Docker Compose 컨테이너
1) `web` (Next.js)
2) `api` (FastAPI)
3) `worker` (Python)
4) `postgres`
5) `redis`

### 7.2 저장소(초기 운영)
- 원본 파일은 서버 로컬에 저장(백업 정책 포함)
- 추후 필요 시 S3 호환 스토리지로 이전 가능하도록 파일 저장 레이어를 추상화

---

## 8. 텍스트 다이어그램

```
[Browser]
   |
   v
[Next.js Web] ---> [FastAPI API] ---> [PostgreSQL]
                      |    |
                      |    +--> [Redis: Queue/Cache]
                      |
                      +--> [Storage: Local (option S3)]
                                |
                                v
                          [Python Worker]
                 (Excel parsing / Image->Table / Matching)
```

